{
  "address": "0x5fE47100E431D179cA75a3322230BBe8EFeAfE02",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_operator",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_rewardFactory",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_proxyFactory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "Unauthorized",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "_newImplementation",
          "type": "address"
        }
      ],
      "name": "ImpelemntationChanged",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_pid",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "_gauge",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_staker",
          "type": "address"
        }
      ],
      "name": "createStash",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "implementation",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "operator",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "proxyFactory",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "rewardFactory",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_newImplementation",
          "type": "address"
        }
      ],
      "name": "setImplementation",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x1e0c082ba781c898e4392ef7a40b78f49438bab9d29e2bcf53df09440f21e3e2",
  "receipt": {
    "to": null,
    "from": "0xbF63Afb77A49159b4502E91CD3f4EbDcc161431f",
    "contractAddress": "0x5fE47100E431D179cA75a3322230BBe8EFeAfE02",
    "transactionIndex": 6,
    "gasUsed": "364247",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x5cf33de40571e6c89c06805e546d8287bb5fc3b1baa61d735f62f1e15ce41672",
    "transactionHash": "0x1e0c082ba781c898e4392ef7a40b78f49438bab9d29e2bcf53df09440f21e3e2",
    "logs": [],
    "blockNumber": 32274884,
    "cumulativeGasUsed": "1212624",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x2d5852C1202c0a7A12387343c8868FCE53a3a97a",
    "0x59B836223D8d6339D10523a19f04a37f75707B3E",
    "0x2B1853D3EAe7B91A5aAAa26a477C5A817Cb70579"
  ],
  "solcInputHash": "ffe7c3d313508848a216b8f00aa6ff1c",
  "metadata": "{\"compiler\":{\"version\":\"0.8.14+commit.80d49f37\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_operator\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_rewardFactory\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_proxyFactory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"Unauthorized\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"ImpelemntationChanged\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_pid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"_gauge\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"createStash\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"proxyFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"rewardFactory\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newImplementation\",\"type\":\"address\"}],\"name\":\"setImplementation\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"createStash(uint256,address,address)\":{\"params\":{\"_gauge\":\"Gauge address\",\"_pid\":\"The PID of the pool\",\"_staker\":\"Staker's address\"}},\"setImplementation(address)\":{\"params\":{\"_newImplementation\":\"Address of new implementation contract\"}}},\"title\":\"Stash Factory\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"createStash(uint256,address,address)\":{\"notice\":\"Create a stash contract for the given gauge\"},\"setImplementation(address)\":{\"notice\":\"Used to set address for new implementation contract\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/factories/StashFactory.sol\":\"StashFactory\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address from,\\n        address to,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0xbbc8ac883ac3c0078ce5ad3e288fbb3ffcc8a30c3a98c0fda0114d64fc44fca2\",\"license\":\"MIT\"},\"contracts/factories/StashFactory.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport \\\"../utils/Interfaces.sol\\\";\\n\\n/// @title Stash Factory\\ncontract StashFactory is IStashFactory {\\n    event ImpelemntationChanged(address _newImplementation);\\n\\n    error Unauthorized();\\n\\n    address public immutable operator;\\n    address public immutable rewardFactory;\\n    address public immutable proxyFactory;\\n\\n    address public implementation;\\n\\n    constructor(\\n        address _operator,\\n        address _rewardFactory,\\n        address _proxyFactory\\n    ) {\\n        operator = _operator;\\n        rewardFactory = _rewardFactory;\\n        proxyFactory = _proxyFactory;\\n    }\\n\\n    /// @notice Used to set address for new implementation contract\\n    /// @param _newImplementation Address of new implementation contract\\n    function setImplementation(address _newImplementation) external {\\n        if (msg.sender != IController(operator).owner()) {\\n            revert Unauthorized();\\n        }\\n        implementation = _newImplementation;\\n        emit ImpelemntationChanged(_newImplementation);\\n    }\\n\\n    /// @notice Create a stash contract for the given gauge\\n    /// @param _pid The PID of the pool\\n    /// @param _gauge Gauge address\\n    /// @param _staker Staker's address\\n    function createStash(\\n        uint256 _pid,\\n        address _gauge,\\n        address _staker\\n    ) external returns (address) {\\n        if (msg.sender != operator) {\\n            revert Unauthorized();\\n        }\\n        address stash = IProxyFactory(proxyFactory).clone(implementation);\\n        IStash(stash).initialize(\\n            _pid,\\n            msg.sender,\\n            _staker,\\n            _gauge,\\n            rewardFactory\\n        );\\n        return stash;\\n    }\\n}\\n\",\"keccak256\":\"0xc12dfb8ca973aef79f0eb2a77ae6f54c8180fcd862e1f014b85207ebb7a83af8\",\"license\":\"MIT\"},\"contracts/utils/Interfaces.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity 0.8.14;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\n\\ninterface IBalGauge {\\n    function deposit(uint256) external;\\n\\n    function balanceOf(address) external view returns (uint256);\\n\\n    function withdraw(uint256) external;\\n\\n    function claim_rewards() external;\\n\\n    function reward_tokens(uint256) external view returns (address);\\n\\n    function lp_token() external view returns (address);\\n}\\n\\ninterface IBalVoteEscrow {\\n    function create_lock(uint256, uint256) external;\\n\\n    function increase_amount(uint256) external;\\n\\n    function increase_unlock_time(uint256) external;\\n\\n    function withdraw() external;\\n\\n    function smart_wallet_checker() external view returns (address);\\n\\n    function balanceOf(address, uint256) external view returns (uint256);\\n\\n    function balanceOfAt(address, uint256) external view returns (uint256);\\n}\\n\\ninterface IWalletChecker {\\n    function check(address) external view returns (bool);\\n}\\n\\ninterface IVoting {\\n    function vote_for_gauge_weights(address, uint256) external;\\n}\\n\\ninterface IMinter {\\n    function mint(address) external;\\n}\\n\\ninterface IVoterProxy {\\n    function deposit(address _token, address _gauge) external;\\n\\n    function withdrawWethBal(address, uint256) external;\\n\\n    function withdraw(IERC20 _asset) external returns (uint256 balance);\\n\\n    function withdraw(\\n        address _token,\\n        address _gauge,\\n        uint256 _amount\\n    ) external;\\n\\n    function withdrawAll(address _token, address _gauge) external;\\n\\n    function createLock(uint256 _value, uint256 _unlockTime) external;\\n\\n    function increaseAmount(uint256 _value) external;\\n\\n    function increaseTime(uint256 _unlockTimestamp) external;\\n\\n    function release() external;\\n\\n    function claimBal(address _gauge) external returns (uint256);\\n\\n    function claimRewards(address _gauge) external;\\n\\n    function claimFees(address _distroContract, IERC20 _token)\\n        external\\n        returns (uint256);\\n\\n    function grantStashAccess(address _stash) external;\\n\\n    function delegateVotingPower(address _delegateTo) external;\\n\\n    function clearDelegate() external;\\n\\n    function voteMultipleGauges(\\n        address[] calldata _gauges,\\n        uint256[] calldata _weights\\n    ) external;\\n\\n    function balanceOfPool(address _gauge) external view returns (uint256);\\n\\n    function operator() external view returns (address);\\n\\n    function execute(\\n        address _to,\\n        uint256 _value,\\n        bytes calldata _data\\n    ) external returns (bool, bytes memory);\\n}\\n\\ninterface ISnapshotDelegateRegistry {\\n    function setDelegate(bytes32 id, address delegate) external;\\n\\n    function clearDelegate(bytes32 id) external;\\n}\\n\\ninterface IRewards {\\n    function stake(address, uint256) external;\\n\\n    function stakeFor(address, uint256) external;\\n\\n    function withdraw(address, uint256) external;\\n\\n    function exit(address) external;\\n\\n    function getReward(address) external;\\n\\n    function queueNewRewards(uint256) external;\\n\\n    function notifyRewardAmount(uint256) external;\\n\\n    function addExtraReward(address) external;\\n\\n    function stakingToken() external view returns (address);\\n\\n    function rewardToken() external view returns (address);\\n\\n    function earned(address account) external view returns (uint256);\\n}\\n\\ninterface IStash {\\n    function processStash() external;\\n\\n    function claimRewards() external;\\n\\n    function initialize(\\n        uint256 _pid,\\n        address _operator,\\n        address _staker,\\n        address _gauge,\\n        address _rewardFactory\\n    ) external;\\n}\\n\\ninterface IFeeDistro {\\n    /**\\n     * @notice Claims all pending distributions of the provided token for a user.\\n     * @dev It's not necessary to explicitly checkpoint before calling this function, it will ensure the FeeDistributor\\n     * is up to date before calculating the amount of tokens to be claimed.\\n     * @param user - The user on behalf of which to claim.\\n     * @param token - The ERC20 token address to be claimed.\\n     * @return The amount of `token` sent to `user` as a result of claiming.\\n     */\\n    function claimToken(address user, IERC20 token) external returns (uint256);\\n\\n    /**\\n     * @notice Claims a number of tokens on behalf of a user.\\n     * @dev A version of `claimToken` which supports claiming multiple `tokens` on behalf of `user`.\\n     * See `claimToken` for more details.\\n     * @param user - The user on behalf of which to claim.\\n     * @param tokens - An array of ERC20 token addresses to be claimed.\\n     * @return An array of the amounts of each token in `tokens` sent to `user` as a result of claiming.\\n     */\\n    function claimTokens(address user, IERC20[] calldata tokens)\\n        external\\n        returns (uint256[] memory);\\n}\\n\\ninterface ITokenMinter {\\n    function mint(address, uint256) external;\\n\\n    function burn(address, uint256) external;\\n}\\n\\ninterface IBaseRewardsPool {\\n    function totalSupply() external view returns (uint256);\\n\\n    function balanceOf(address _account) external view returns (uint256);\\n}\\n\\ninterface IController {\\n    /// @notice returns the number of pools\\n    function poolLength() external returns (uint256);\\n\\n    /// @notice Deposits an amount of LP token into a specific pool,\\n    /// mints reward and optionally tokens and  stakes them into the reward contract\\n    /// @dev Sender must approve LP tokens to Controller smart contract\\n    /// @param _pid The pool id to deposit lp tokens into\\n    /// @param _amount The amount of lp tokens to be deposited\\n    /// @param _stake bool for wheather the tokens should be staked\\n    function deposit(\\n        uint256 _pid,\\n        uint256 _amount,\\n        bool _stake\\n    ) external;\\n\\n    /// @notice Deposits and stakes all LP tokens\\n    /// @dev Sender must approve LP tokens to Controller smart contract\\n    /// @param _pid The pool id to deposit lp tokens into\\n    /// @param _stake bool for wheather the tokens should be staked\\n    function depositAll(uint256 _pid, bool _stake) external;\\n\\n    /// @notice Withdraws lp tokens from the pool\\n    /// @param _pid The pool id to withdraw lp tokens from\\n    /// @param _amount amount of LP tokens to withdraw\\n    function withdraw(uint256 _pid, uint256 _amount) external;\\n\\n    /// @notice Withdraws all of the lp tokens in the pool\\n    /// @param _pid The pool id to withdraw lp tokens from\\n    function withdrawAll(uint256 _pid) external;\\n\\n    /// @notice Withdraws LP tokens and sends them to a specified address\\n    /// @param _pid The pool id to deposit lp tokens into\\n    /// @param _amount amount of LP tokens to withdraw\\n    function withdrawTo(\\n        uint256 _pid,\\n        uint256 _amount,\\n        address _to\\n    ) external;\\n\\n    /// @notice Withdraws `amount` of unlocked WethBal to treasury\\n    /// @param _amount amount of tokens to withdraw\\n    function withdrawUnlockedWethBal(uint256 _amount) external;\\n\\n    /// @notice Claims rewards from a pool and disperses them to the rewards contract\\n    /// @param _pid the id of the pool where lp tokens are held\\n    function earmarkRewards(uint256 _pid) external;\\n\\n    /// @notice Claims fees from the Balancer's fee distributor contract and transfers the tokens into the rewards contract\\n    function earmarkFees() external;\\n\\n    function isShutdown() external view returns (bool);\\n\\n    function poolInfo(uint256)\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            address,\\n            address,\\n            address,\\n            bool\\n        );\\n\\n    function claimRewards(uint256, address) external;\\n\\n    function setGaugeRedirect(uint256 _pid) external;\\n\\n    function owner() external returns (address);\\n}\\n\\ninterface ICrvDeposit {\\n    function deposit(uint256, bool) external;\\n\\n    function lockIncentive() external view returns (uint256);\\n}\\n\\ninterface IRewardFactory {\\n    function grantRewardStashAccess(address) external;\\n\\n    function createBalRewards(uint256, address) external returns (address);\\n\\n    function createTokenRewards(\\n        address,\\n        address,\\n        address\\n    ) external returns (address);\\n\\n    function activeRewardCount(address) external view returns (uint256);\\n\\n    function addActiveReward(address, uint256) external returns (bool);\\n\\n    function removeActiveReward(address, uint256) external returns (bool);\\n}\\n\\ninterface IStashFactory {\\n    function createStash(\\n        uint256,\\n        address,\\n        address\\n    ) external returns (address);\\n}\\n\\ninterface ITokenFactory {\\n    function createDepositToken(address) external returns (address);\\n}\\n\\ninterface IPools {\\n    function addPool(address, address) external returns (bool);\\n\\n    function forceAddPool(address, address) external returns (bool);\\n\\n    function shutdownPool(uint256) external returns (bool);\\n\\n    function poolInfo(uint256)\\n        external\\n        view\\n        returns (\\n            address,\\n            address,\\n            address,\\n            address,\\n            address,\\n            bool\\n        );\\n\\n    function poolLength() external view returns (uint256);\\n\\n    function gaugeMap(address) external view returns (bool);\\n\\n    function setPoolManager(address _poolM) external;\\n}\\n\\ninterface IVestedEscrow {\\n    function fund(address[] calldata _recipient, uint256[] calldata _amount)\\n        external\\n        returns (bool);\\n}\\n\\ninterface GaugeController {\\n    function gauge_types(address _addr) external returns (int128);\\n}\\n\\ninterface LiquidityGauge {\\n    function integrate_fraction(address _address) external returns (uint256);\\n\\n    function user_checkpoint(address _address) external returns (bool);\\n}\\n\\ninterface IProxyFactory {\\n    function clone(address _target) external returns (address);\\n}\\n\\ninterface IRewardHook {\\n    function onRewardClaim() external;\\n}\\n\",\"keccak256\":\"0x8b7e0f0261e1c084438eac5a14d2e6d09bcbee4e4d1d7ea33eb4c508f616eb0e\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60e060405234801561001057600080fd5b5060405161069138038061069183398101604081905261002f91610068565b6001600160a01b0392831660805290821660a0521660c0526100ab565b80516001600160a01b038116811461006357600080fd5b919050565b60008060006060848603121561007d57600080fd5b6100868461004c565b92506100946020850161004c565b91506100a26040850161004c565b90509250925092565b60805160a05160c05161059d6100f4600039600081816101260152610217015260008181607c01526102e001526000818160cc015281816101770152610353015261059d6000f3fe608060405234801561001057600080fd5b50600436106100725760003560e01c8063b92d538711610050578063b92d53871461010e578063c10f1a7514610121578063d784d4261461014857600080fd5b8063245e4bf014610077578063570ca735146100c75780635c60da1b146100ee575b600080fd5b61009e7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b61009e7f000000000000000000000000000000000000000000000000000000000000000081565b60005461009e9073ffffffffffffffffffffffffffffffffffffffff1681565b61009e61011c3660046104e4565b61015d565b61009e7f000000000000000000000000000000000000000000000000000000000000000081565b61015b610156366004610526565b610351565b005b60003373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146101ce576040517f82b4290000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080546040517f8124b78e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff91821660048201527f000000000000000000000000000000000000000000000000000000000000000090911690638124b78e906024016020604051808303816000875af1158015610262573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610286919061054a565b6040517f3641e0830000000000000000000000000000000000000000000000000000000081526004810187905233602482015273ffffffffffffffffffffffffffffffffffffffff858116604483015286811660648301527f00000000000000000000000000000000000000000000000000000000000000008116608483015291925090821690633641e0839060a401600060405180830381600087803b15801561033057600080fd5b505af1158015610344573d6000803e3d6000fd5b5092979650505050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b81526004016020604051808303816000875af11580156103be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103e2919061054a565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610446576040517f82b4290000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f7257141c42cbfb2d9a0e100abb7adaed82a5b3c36107b22bc02efe8122ae81479060200160405180910390a150565b73ffffffffffffffffffffffffffffffffffffffff811681146104e157600080fd5b50565b6000806000606084860312156104f957600080fd5b83359250602084013561050b816104bf565b9150604084013561051b816104bf565b809150509250925092565b60006020828403121561053857600080fd5b8135610543816104bf565b9392505050565b60006020828403121561055c57600080fd5b8151610543816104bf56fea2646970667358221220daae66eff40c3746b18e5901ba5cfff0da07767e3e7ce1e8ae57f8c4be161cb464736f6c634300080e0033",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100725760003560e01c8063b92d538711610050578063b92d53871461010e578063c10f1a7514610121578063d784d4261461014857600080fd5b8063245e4bf014610077578063570ca735146100c75780635c60da1b146100ee575b600080fd5b61009e7f000000000000000000000000000000000000000000000000000000000000000081565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b61009e7f000000000000000000000000000000000000000000000000000000000000000081565b60005461009e9073ffffffffffffffffffffffffffffffffffffffff1681565b61009e61011c3660046104e4565b61015d565b61009e7f000000000000000000000000000000000000000000000000000000000000000081565b61015b610156366004610526565b610351565b005b60003373ffffffffffffffffffffffffffffffffffffffff7f000000000000000000000000000000000000000000000000000000000000000016146101ce576040517f82b4290000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080546040517f8124b78e00000000000000000000000000000000000000000000000000000000815273ffffffffffffffffffffffffffffffffffffffff91821660048201527f000000000000000000000000000000000000000000000000000000000000000090911690638124b78e906024016020604051808303816000875af1158015610262573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610286919061054a565b6040517f3641e0830000000000000000000000000000000000000000000000000000000081526004810187905233602482015273ffffffffffffffffffffffffffffffffffffffff858116604483015286811660648301527f00000000000000000000000000000000000000000000000000000000000000008116608483015291925090821690633641e0839060a401600060405180830381600087803b15801561033057600080fd5b505af1158015610344573d6000803e3d6000fd5b5092979650505050505050565b7f000000000000000000000000000000000000000000000000000000000000000073ffffffffffffffffffffffffffffffffffffffff16638da5cb5b6040518163ffffffff1660e01b81526004016020604051808303816000875af11580156103be573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906103e2919061054a565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610446576040517f82b4290000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600080547fffffffffffffffffffffffff00000000000000000000000000000000000000001673ffffffffffffffffffffffffffffffffffffffff83169081179091556040519081527f7257141c42cbfb2d9a0e100abb7adaed82a5b3c36107b22bc02efe8122ae81479060200160405180910390a150565b73ffffffffffffffffffffffffffffffffffffffff811681146104e157600080fd5b50565b6000806000606084860312156104f957600080fd5b83359250602084013561050b816104bf565b9150604084013561051b816104bf565b809150509250925092565b60006020828403121561053857600080fd5b8135610543816104bf565b9392505050565b60006020828403121561055c57600080fd5b8151610543816104bf56fea2646970667358221220daae66eff40c3746b18e5901ba5cfff0da07767e3e7ce1e8ae57f8c4be161cb464736f6c634300080e0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "createStash(uint256,address,address)": {
        "params": {
          "_gauge": "Gauge address",
          "_pid": "The PID of the pool",
          "_staker": "Staker's address"
        }
      },
      "setImplementation(address)": {
        "params": {
          "_newImplementation": "Address of new implementation contract"
        }
      }
    },
    "title": "Stash Factory",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "createStash(uint256,address,address)": {
        "notice": "Create a stash contract for the given gauge"
      },
      "setImplementation(address)": {
        "notice": "Used to set address for new implementation contract"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 7520,
        "contract": "contracts/factories/StashFactory.sol:StashFactory",
        "label": "implementation",
        "offset": 0,
        "slot": "0",
        "type": "t_address"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      }
    }
  }
}