{
  "language": "Solidity",
  "sources": {
    "contracts/test/veBalMock.sol": {
      "content": "//mock of vebal contract from mainnet\n//by address 0xC128a9954e6c874eA3d62ce62B468bA073093F25\n\n// solium-disable linebreak-style\npragma solidity 0.8.13;\n\n// import \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\n\ninterface BAL_ERC20 { //was just ERC20 in their Vyper contract\n    function decimals() external view returns (uint256);\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function transfer(address to, uint256 amount) external returns (bool); //nonpayable\n    function transferFrom(address spender, address to, uint256 amount) external returns (bool); //nonpayable\n}\n// Interface for checking whether address belongs to a whitelisted\n// type of a smart wallet.\n// When new types are added - the whole contract is changed\n// The check() method is modifying to be able to use caching\n// for individual wallet addresses \ninterface SmartWalletChecker {\n    function check(address addr) external returns (bool);//nonpayable\n}   \n\n// contract BalMock is ERC20, ReentrancyGuard, SmartWalletChecker, BALERC20 {\ncontract veBalMock is ReentrancyGuard {\n// contract BalMock is BAL_ERC20, SmartWalletChecker{//}, ReentrancyGuard {\n\n    struct Point{\n        int128 bias;\n        int128 slope; // - dweight / dt\n        uint256 ts;\n        uint256 blk; // block\n    }\n    // We cannot really do block numbers per se b/c slope is per time, not per block\n    // and per block could be fairly bad b/c Ethereum changes blocktimes.\n    // What we can do is to extrapolate ***At functions\n\n    struct LockedBalance{\n        int128 amount; \n        uint256 end;\n    }  \n\n    address constant ZERO_ADDRESS = address(0x0000000000000000000000000000000000000000);\n\n    int128 constant DEPOSIT_FOR_TYPE = 0;\n    int128 constant CREATE_LOCK_TYPE = 1;\n    int128 constant INCREASE_LOCK_AMOUNT = 2;\n    int128 constant INCREASE_UNLOCK_TIME = 3;\n\n    event Deposit(address indexed provider, uint256 value, uint256 indexed locktime, int128 type_, uint256 ts); //if just type without _ --> was highlited as error\n    event Withdraw(address indexed provider, uint256 value, uint256 ts);\n    event Supply(uint256 prevSupply, uint256 supply);\n\n    uint256 constant WEEK = 7 * 86400; //all future times are rounded by week\n    uint256 constant MAXTIME = 365 * 86400;  // 1 year\n    uint256 constant MULTIPLIER = 10 ** 18;\n\n\n    address immutable TOKEN; \n    address immutable AUTHORIZER_ADAPTOR; //Authorizer Adaptor\n\n    //string is not succorted to be immutable in solidity\n    string public NAME; //immutable NAME;\n    string public SYMBOL; //immutable SYMBOL; \n    uint256 immutable DECIMALS;\n\n    // uint256 public supply;\n    mapping(address => uint256) supply;\n    uint256 private _totalSupply;\n\n    mapping(address => LockedBalance) public locked;\n\n    uint256 public epoch;\n\n    Point[100000000000000000000000000000] public point_history; //epoch -> unsigned point\n    mapping(address => Point[1000000000]) private user_point_history; //user -> Point[user_epoch]\n    mapping(address => uint256) public user_point_epoch;\n    mapping(uint256 => int128) public slope_changes; //time -> signed slope change\n\n    // Checker for whitelisted (smart contract) wallets which are allowed to deposit\n    // The goal is to prevent tokenizing the escrow\n    address public future_smart_wallet_checker;\n    address public smart_wallet_checker;\n\n\n    //__init__\n    constructor(\n        address token_addr,\n        string memory _name,\n        string memory  _symbol,\n        address _authorizer_adaptor\n    ) //ERC20(_name, _symbol)\n    public {\n        /**\n        @notice Contract constructor\n        @param token_addr 80/20 BAL-WETH BPT token address\n        @param _name Token name\n        @param _symbol Token symbol\n        @param _authorizer_adaptor `AuthorizerAdaptor` contract address\n        */\n        require(_authorizer_adaptor != ZERO_ADDRESS, \"BalMock: _authorizer_adaptor == ZERO_ADDRESS\");\n\n        TOKEN = token_addr;\n        AUTHORIZER_ADAPTOR = _authorizer_adaptor;\n        point_history[0].blk = block.number;\n        point_history[0].ts = block.timestamp;\n\n        uint256 _decimals = BAL_ERC20(token_addr).decimals();\n        require(_decimals <= 255, \"BalMock: _decimals > 255\");\n\n        NAME = _name;\n        SYMBOL = _symbol;\n        DECIMALS = _decimals;\n    }\n\n\n    function token() external view returns (address){\n        return TOKEN;\n    }\n    function name() public view virtual returns (string memory){\n        return NAME;\n    }\n    function symbol() public view virtual returns (string memory){\n        return SYMBOL;\n    }\n    function decimals() public view virtual returns (uint256){\n        return DECIMALS;\n    }\n    function admin() external view returns (address){\n        return AUTHORIZER_ADAPTOR;\n    }\n    function commit_smart_wallet_checker(address addr) external {}\n    function apply_smart_wallet_checker() external {}\n    function assert_not_contract(address addr) internal {}    \n    function get_last_user_slope(address addr) external view returns (int128){\n        /**\n        @notice Get the most recently recorded rate of voting power decrease for `addr`\n        @param addr Address of the user wallet\n        @return Value of the slope\n        */\n        uint256 uepoch = user_point_epoch[addr];\n        return user_point_history[addr][uepoch].slope;\n    }\n    function user_point_history__ts(address _addr, uint256 _idx) external view returns (uint256){\n        /**\n        @notice Get the timestamp for checkpoint `_idx` for `_addr`\n        @param _addr User wallet address\n        @param _idx User epoch number\n        @return Epoch time of the checkpoint\n    */\n        return user_point_history[_addr][_idx].ts;\n    }\n    function locked__end(address _addr) external view returns (uint256){\n        /**\n        @notice Get timestamp when `_addr`'s lock finishes\n        @param _addr User wallet\n        @return Epoch time of the lock end\n        */\n        return locked[_addr].end;\n    }\n\n// FROM ERC20\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        supply[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n// FROM ERC20 END\n\n    function _checkpoint(address addr, LockedBalance memory old_locked, LockedBalance memory new_locked) internal {}\n    function _deposit_for(address _addr, uint256 _value, uint256 unlock_time, LockedBalance memory locked_balance, int128 type_) internal {}\n    function checkpoint() external {}\n    function deposit_for(address _addr, uint256 _value) external nonReentrant {\n        _mint(_addr, _value);\n    }\n\n    function create_lock(uint256 tokens) external nonReentrant {\n        _mint(msg.sender, tokens);\n        // BAL_ERC20(TOKEN).transferFrom(msg.sender, tokens);\n    }\n\n    function increase_amount(uint256) external nonReentrant {}\n    function increase_unlock_time(uint256 _unlock_time) external nonReentrant {}\n    function withdraw() external nonReentrant {}\n\n    // The following ERC20/minime-compatible methods are not real balanceOf and supply!\n    // They measure the weights for the purpose of voting, so they don't represent\n    // real coins.\n\n    function find_block_epoch(uint256 _block, uint256 max_epoch) internal view returns (uint256){\n        /**\n        @notice Binary search to find epoch containing block number\n        @param _block Block to find\n        @param max_epoch Don't go beyond this epoch\n        @return Epoch which contains _block\n        */\n\n        // Binary search\n        uint256 _min = 0;\n        uint256 _max = max_epoch;\n        //some code\n\n        return _min;\n    }\n    function find_timestamp_epoch(uint256 _timestamp, uint256 max_epoch) internal view returns (uint256){\n        /**\n        @notice Binary search to find epoch for timestamp\n        @param _timestamp timestamp to find\n        @param max_epoch Don't go beyond this epoch\n        @return Epoch which contains _timestamp\n        */\n\n        // Binary search\n        uint256 _min = 0;\n        uint256 _max = max_epoch;\n        //some code\n        \n        return _min;\n    }\n    function find_block_user_epoch(address addr, uint256 _block, uint256 max_epoch) internal view returns (uint256){\n        /**\n        @notice Binary search to find epoch for block number\n        @param _addr User for which to find user epoch for\n        @param _block Block to find\n        @param max_epoch Don't go beyond this epoch\n        @return Epoch which contains _block\n        */\n\n        // Binary search\n        uint256 _min = 0;\n        uint256 _max = max_epoch;\n        //some code\n        \n        return _min;\n    }\n    function find_timestamp_user_epoch(address addr, uint256 _timestamp, uint256 max_epoch) internal view returns (uint256){\n        /**\n        @notice Binary search to find user epoch for timestamp\n        @param _addr User for which to find user epoch for\n        @param _timestamp timestamp to find\n        @param max_epoch Don't go beyond this epoch\n        @return Epoch which contains _timestamp\n        */\n\n        // Binary search\n        uint256 _min = 0;\n        uint256 _max = max_epoch;\n        //some code\n        \n        return _min;\n    }\n    function balanceOf(address addr, uint256 _t) external view returns (uint256){\n        /**\n        @notice Get the current voting power for `msg.sender`\n        @dev Adheres to the ERC20 `balanceOf` interface for Aragon compatibility\n        @param addr User wallet address\n        @param _t Epoch time to return voting power at\n        @return User voting power\n        */\n        uint256 _t = block.timestamp;\n\n        //some code and actual rerurn is not 1\n        return 1;\n    }\n    function balanceOfAt(address addr, uint256 _block) external view returns (uint256){\n        //some code and actual rerurn is not 1\n        return 1;\n    }\n    function supply_at(Point memory p, uint256 t) internal view returns (uint256){\n        //some code and actual rerurn is not 1\n        return 1;    \n    }\n    function totalSupply(uint256 t) external view returns (uint256){\n        uint256 t = block.timestamp;\n        //some code and actual rerurn is not 1\n        return 1;    \n    }\n    function totalSupplyAt(uint256 _block) external view returns (uint256){\n        /**\n        @notice Calculate total voting power at some point in the past\n        @param _block Block to calculate the total voting power at\n        @return Total voting power at `_block`\n        */\n\n        require(_block <= block.number, \"_block > block.number\");\n        uint256 _epoch = epoch;\n        uint256 target_epoch = find_block_epoch(_block, _epoch);\n\n        Point memory point = point_history[target_epoch];\n        uint256 dt = 0;\n        if (target_epoch < _epoch){\n            Point memory point_next = point_history[target_epoch + 1];\n            if (point.blk != point_next.blk){\n                dt = (_block - point.blk) * (point_next.ts - point.ts) / (point_next.blk - point.blk);\n            }\n        }else{\n            if (point.blk != block.number){\n                dt = (_block - point.blk) * (block.timestamp - point.ts) / (block.number - point.blk);\n            }\n        }\n        // Now dt contains info on how far are we beyond point\n\n        return supply_at(point, point.ts + dt);\n\n        //some code and actual return is not 1\n        // return 1; \n    }\n\n}\n\n\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}